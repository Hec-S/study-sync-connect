import { useAuth } from "@/contexts/AuthContext";
import { useNotifications } from "@/contexts/NotificationsContext";
import { Navbar } from "@/components/Navbar";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { NotificationBadge } from "@/components/ui/notification-badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { UserPlus, Users, Check, X, MessageSquare, Send, Folder } from "lucide-react";
import { PortfolioFeedCard } from "@/components/portfolio/PortfolioFeedCard";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import React, { useEffect, useState, useRef } from "react";
import type { Connection, Message, Project } from "@/integrations/supabase/types";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Link, useSearchParams } from "react-router-dom";

type Profile = {
  full_name: string | null;
  school_name: string | null;
};

type ConnectionWithProfile = Connection & {
  other_user_profile: Profile | null;
};

type MessageWithProfile = Message & {
  sender_profile: Profile | null;
  receiver_profile: Profile | null;
};

type DatabasePortfolioItem = {
  id: string;
  title: string;
  description: string;
  image_url?: string;
  owner_id: string;
  created_at: string;
  updated_at: string;
  category: string;
  completion_date?: string;
  project_url?: string;
  skills: string[];
  likes_count?: number;
  comments_count?: number;
};

type PortfolioItem = DatabasePortfolioItem & {
  likes_count: number;
  comments_count: number;
  is_liked?: boolean;
  user_profile: Profile | null;
};

// Helper function to get counts from the database response
const getCounts = (item: any) => ({
  likes_count: item.likes_count || 0,
  comments_count: item.comments_count || 0
});

export const ConnectionsPage = () => {
  const { user } = useAuth();
  const { toast } = useToast();
  const [searchParams, setSearchParams] = useSearchParams();
  const { messageCount: unreadMessages, requestCount: pendingConnectionsCount, refreshCounts, markMessagesAsRead } = useNotifications();
  const [connections, setConnections] = useState<ConnectionWithProfile[]>([]);
  const [pendingRequests, setPendingRequests] = useState<ConnectionWithProfile[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [messages, setMessages] = useState<MessageWithProfile[]>([]);
  const [activeConversation, setActiveConversation] = useState<string | null>(null);
  const [newMessage, setNewMessage] = useState('');
  const messageEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const [isAtBottom, setIsAtBottom] = useState(true);
  const messageContainerRef = useRef<HTMLDivElement>(null);
  const [messageOffset, setMessageOffset] = useState(0);
  const [hasMoreMessages, setHasMoreMessages] = useState(true);
  const [isLoadingMoreMessages, setIsLoadingMoreMessages] = useState(false);
  const [previousScrollHeight, setPreviousScrollHeight] = useState(0);
  
  // Auto-scroll to bottom when conversation changes or new messages arrive, but only if already at bottom
  useEffect(() => {
    if (activeConversation && messageEndRef.current && isAtBottom) {
      messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [activeConversation, messages, isAtBottom]);
  
  // Handle scroll events in the message container
  const handleMessageScroll = () => {
    if (!messageContainerRef.current) return;
    
    const { scrollTop, scrollHeight, clientHeight } = messageContainerRef.current;
    // Consider "at bottom" if within 100px of the bottom
    const atBottom = scrollHeight - scrollTop - clientHeight < 100;
    setIsAtBottom(atBottom);
    
    // Check if user is near the top (within 50px) to load more messages
    const isNearTop = scrollTop < 50;
    if (isNearTop && !isLoadingMoreMessages && hasMoreMessages && activeConversation && messages.length > 0) {
      // Save current scroll height before loading more messages
      setPreviousScrollHeight(scrollHeight);
      // Load more messages
      loadMoreMessages();
    }
  };
  
  // Function to load more messages
  const loadMoreMessages = async () => {
    if (!user?.id || !hasMoreMessages || isLoadingMoreMessages) return;
    
    setIsLoadingMoreMessages(true);
    try {
      const newOffset = messageOffset + 50; // Load 50 more messages
      
      // Get older messages with pagination for the active conversation
      const { data: messagesData, error: messagesError } = await supabase
        .from('messages')
        .select('*, read_status')
        .or(`sender_id.eq.${user.id},receiver_id.eq.${activeConversation},receiver_id.eq.${user.id},sender_id.eq.${activeConversation}`)
        .order('created_at', { ascending: false }) // Newest first for pagination
        .range(newOffset, newOffset + 49);
      
      if (messagesError) {
        console.error('Error fetching more messages:', messagesError);
        throw messagesError;
      }
      
      // If no more messages, set hasMoreMessages to false
      if (!messagesData || messagesData.length < 50) {
        setHasMoreMessages(false);
      }
      
      if (!messagesData?.length) {
        setIsLoadingMoreMessages(false);
        return;
      }
      
      // Reverse to show oldest first in the UI
      const chronologicalMessages = [...messagesData].reverse();
      
      // Transform messages with sender and receiver profiles
      const transformedMessages = await Promise.all(chronologicalMessages.map(async (message) => {
        const [senderResponse, receiverResponse] = await Promise.all([
          supabase
            .from('profiles')
            .select('full_name, school_name')
            .eq('id', message.sender_id)
            .single(),
          supabase
            .from('profiles')
            .select('full_name, school_name')
            .eq('id', message.receiver_id)
            .single()
        ]);
        
        return {
          ...message,
          sender_profile: senderResponse.data,
          receiver_profile: receiverResponse.data
        };
      }));
      
      // Add older messages to the beginning of the messages array
      setMessages(prev => [...transformedMessages, ...prev]);
      setMessageOffset(newOffset);
      
      // Restore scroll position after new messages are loaded
      setTimeout(() => {
        if (messageContainerRef.current) {
          const newScrollHeight = messageContainerRef.current.scrollHeight;
          const scrollDifference = newScrollHeight - previousScrollHeight;
          // Add a small buffer to ensure we're not right at the top
          messageContainerRef.current.scrollTop = scrollDifference > 0 ? scrollDifference + 10 : 10;
        }
      }, 200);
      
    } catch (error) {
      console.error('Error loading more messages:', error);
      toast({
        title: "Error",
        description: "Failed to load more messages",
        variant: "destructive",
      });
    } finally {
      setIsLoadingMoreMessages(false);
    }
  };
  
  // Function to scroll to bottom on demand
  const scrollToBottom = () => {
    if (messageEndRef.current) {
      messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
      setIsAtBottom(true);
    }
  };
  
  // Focus input when conversation changes
  useEffect(() => {
    if (activeConversation && inputRef.current) {
      inputRef.current.focus();
    }
  }, [activeConversation]);
  const [portfolioProjects, setPortfolioProjects] = useState<PortfolioItem[]>([]);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  // Set initial tab from URL
  useEffect(() => {
    const tab = searchParams.get('tab');
    if (tab === 'messages' && activeConversation) {
      handleTabChange('messages');
    }
  }, [searchParams]);

  useEffect(() => {
    if (user) {
      Promise.all([
        fetchConnections(),
        fetchPendingRequests(),
        fetchMessages(),
        fetchPortfolioProjects()
      ]).finally(() => setIsLoading(false));

      // Subscribe to message changes
      const subscription = supabase
        .channel('messages')
        .on('postgres_changes', 
          { 
            event: '*', 
            schema: 'public', 
            table: 'messages',
            filter: 'receiver_id=eq.' + user.id
          },
          async (payload) => {
            if (payload.eventType === 'INSERT') {
              // Fetch complete message data with profiles separately
              const newMessage = payload.new as Message;
              const [senderResponse, receiverResponse] = await Promise.all([
                supabase
                  .from('profiles')
                  .select('full_name, school_name')
                  .eq('id', newMessage.sender_id)
                  .single(),
                supabase
                  .from('profiles')
                  .select('full_name, school_name')
                  .eq('id', newMessage.receiver_id)
                  .single()
              ]);

              if (senderResponse.error || receiverResponse.error) {
                console.error('Error fetching profiles:', senderResponse.error || receiverResponse.error);
                return;
              }

              // Add the new message with profiles
              setMessages(prev => [...prev, {
                ...newMessage,
                sender_profile: senderResponse.data,
                receiver_profile: receiverResponse.data
              }]);

              // Only refresh counts for new unread messages
              if (!newMessage.read_status) {
                await refreshCounts();
              }
            } else if (payload.eventType === 'UPDATE') {
              const updatedMessage = payload.new as Message;
              
              // Update message while preserving profile data
              setMessages(prev => prev.map(msg => 
                msg.id === updatedMessage.id
                  ? { ...msg, ...updatedMessage }
                  : msg
              ));

              // If message was marked as read, update the count
              if (payload.old.read_status === false && updatedMessage.read_status === true) {
                await refreshCounts();
              }
            }
          }
        )
        .subscribe();

      return () => {
        subscription.unsubscribe();
      };
    }
  }, [user]);

  // Optimized message loading with pagination
  const fetchMessages = async (limit = 50, offset = 0) => {
    if (!user?.id) return;

    try {
      // Reset pagination state when loading initial messages
      if (offset === 0) {
        setMessageOffset(0);
        setHasMoreMessages(true);
      }
      
      // Get messages with pagination for better performance
      const { data: messagesData, error: messagesError } = await supabase
        .from('messages')
        .select('*, read_status')
        .or('sender_id.eq.' + user.id + ',receiver_id.eq.' + user.id)
        .order('created_at', { ascending: false }) // Newest first for pagination
        .range(offset, offset + limit - 1);

      if (messagesError) {
        console.error('Error fetching messages:', messagesError);
        throw messagesError;
      }

      // Reverse to show oldest first in the UI
      const chronologicalMessages = [...(messagesData || [])].reverse();

      // Transform messages with sender and receiver profiles
      const transformedMessages = await Promise.all(chronologicalMessages.map(async (message) => {
        const [senderResponse, receiverResponse] = await Promise.all([
          supabase
            .from('profiles')
            .select('full_name, school_name')
            .eq('id', message.sender_id)
            .single(),
          supabase
            .from('profiles')
            .select('full_name, school_name')
            .eq('id', message.receiver_id)
            .single()
        ]);

        return {
          ...message,
          sender_profile: senderResponse.data,
          receiver_profile: receiverResponse.data
        };
      }));

      setMessages(transformedMessages);
      
      // Auto-scroll to bottom after loading messages, but only if at bottom
      setTimeout(() => {
        if (messageEndRef.current && isAtBottom) {
          messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
        }
      }, 100);
    } catch (error) {
      console.error('Error fetching messages:', error);
      toast({
        title: "Error",
        description: "Failed to load messages",
        variant: "destructive",
      });
    }
  };

  const handleSendMessage = async () => {
    if (!user?.id || !activeConversation || !newMessage.trim()) return;

    const messageContent = newMessage.trim();
    // Clear input immediately for better UX
    setNewMessage('');
    
    try {
      // Insert the new message
      const { data: newMessageData, error } = await supabase
        .from('messages')
        .insert([{
          sender_id: user.id,
          receiver_id: activeConversation,
          content: messageContent,
          read_status: false
        }])
        .select()
        .single();

      if (error) throw error;

      // Get profiles for the new message
      const [senderResponse, receiverResponse] = await Promise.all([
        supabase
          .from('profiles')
          .select('full_name, school_name')
          .eq('id', user.id)
          .single(),
        supabase
          .from('profiles')
          .select('full_name, school_name')
          .eq('id', activeConversation)
          .single()
      ]);

      // Add the new message to state without refetching all messages
      const newMessageWithProfiles = {
        ...newMessageData,
        sender_profile: senderResponse.data,
        receiver_profile: receiverResponse.data
      };

      // Add the new message and auto-scroll to bottom
      setMessages(prev => [...prev, newMessageWithProfiles]);
      
      // Always scroll to bottom after sending a message (Instagram behavior)
      setTimeout(() => {
        if (messageEndRef.current) {
          messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
          setIsAtBottom(true);
        }
      }, 100);
    } catch (error) {
      console.error('Error sending message:', error);
      toast({
        title: "Error",
        description: "Failed to send message",
        variant: "destructive",
      });
    }
  };

  const fetchConnections = async () => {
    if (!user?.id) return;

    try {
      // First get all accepted connections
      const { data: connectionsData, error: connectionsError } = await supabase
        .from('connections')
        .select('*')
        .eq('status', 'accepted')
        .or('requester_id.eq.' + user.id + ',receiver_id.eq.' + user.id)
        .order('created_at', { ascending: false });

      if (connectionsError) throw connectionsError;

      // Then fetch profiles for the other users in each connection
      const transformedConnections = await Promise.all((connectionsData || []).map(async (connection) => {
        const otherUserId = connection.requester_id === user.id 
          ? connection.receiver_id 
          : connection.requester_id;

        const { data: profileData } = await supabase
          .from('profiles')
          .select('full_name, school_name')
          .eq('id', otherUserId)
          .single();

        return {
          ...connection,
          other_user_profile: profileData
        };
      }));

      setConnections(transformedConnections);
    } catch (error) {
      console.error('Error fetching connections:', error);
      toast({
        title: "Error",
        description: "Failed to load connections",
        variant: "destructive",
      });
    }
  };

  const fetchPendingRequests = async () => {
    if (!user?.id) return;

    try {
      // Get pending requests
      const { data: requestsData, error: requestsError } = await supabase
        .from('connections')
        .select('*')
        .eq('receiver_id', user.id)
        .eq('status', 'pending')
        .order('created_at', { ascending: false });

      if (requestsError) throw requestsError;

      // Fetch profiles for requesters
      const transformedRequests = await Promise.all((requestsData || []).map(async (request) => {
        const { data: profileData } = await supabase
          .from('profiles')
          .select('full_name, school_name')
          .eq('id', request.requester_id)
          .single();

        return {
          ...request,
          other_user_profile: profileData
        };
      }));

      setPendingRequests(transformedRequests);
    } catch (error) {
      console.error('Error fetching pending requests:', error);
      toast({
        title: "Error",
        description: "Failed to load pending requests",
        variant: "destructive",
      });
    }
  };

  const handleTabChange = async (value: string) => {
    // Update URL with current tab
    setSearchParams({ tab: value });
    
    // Load more projects when switching to portfolio tab
    if (value === 'portfolio' && portfolioProjects.length === 0) {
      await fetchPortfolioProjects();
    }
  };

  const fetchPortfolioProjects = async (offset = 0) => {
    if (!user?.id || !hasMore) return;

    try {
      setIsLoadingMore(true);

      // First fetch portfolio items
      const { data: projectsData, error: projectsError } = await supabase
        .from('portfolio_items')
        .select('*')
        .order('created_at', { ascending: false })
        .range(offset, offset + 4);

      if (projectsError) throw projectsError;

      // If no more projects, set hasMore to false
      if (!projectsData || projectsData.length < 5) {
        setHasMore(false);
      }

      if (!projectsData?.length) {
        setPortfolioProjects([]);
        return;
      }

      // Then fetch profiles for those items
      const { data: profilesData } = await supabase
        .from('profiles')
        .select('id, full_name, school_name')
        .in('id', projectsData.map(item => item.owner_id));

      // Check which items are liked by the current user
      const { data: likesData } = await supabase
        .from('portfolio_likes')
        .select('portfolio_item_id')
        .eq('user_id', user.id)
        .in('portfolio_item_id', projectsData.map(item => item.id));

      const likedItemIds = new Set(likesData?.map(like => like.portfolio_item_id));

      // Combine the data
      const transformedProjects = projectsData.map(item => {
        const counts = getCounts(item);
        return {
          ...item,
          user_profile: profilesData?.find(profile => profile.id === item.owner_id) || null,
          is_liked: likedItemIds.has(item.id),
          likes_count: counts.likes_count,
          comments_count: counts.comments_count
        };
      });

      setPortfolioProjects(prev => 
        offset === 0 ? transformedProjects : [...prev, ...transformedProjects]
      );
    } catch (error) {
      console.error('Error fetching portfolio projects:', error);
      toast({
        title: "Error",
        description: "Failed to load portfolio projects",
        variant: "destructive",
      });
    } finally {
      setIsLoadingMore(false);
    }
  };

  const handleScroll = async (e: React.UIEvent<HTMLDivElement>) => {
    const bottom = e.currentTarget.scrollHeight - e.currentTarget.scrollTop === e.currentTarget.clientHeight;
    if (bottom && !isLoadingMore && hasMore) {
      await fetchPortfolioProjects(portfolioProjects.length);
    }
  };

  const handleAcceptRequest = async (connectionId: string) => {
    try {
      const { error } = await supabase
        .from('connections')
        .update({ status: 'accepted' })
        .eq('id', connectionId);

      if (error) throw error;

      setPendingRequests(prev => prev.filter(req => req.id !== connectionId));
      await Promise.all([
        fetchConnections(),
        refreshCounts()
      ]);

      toast({
        title: "Success",
        description: "Connection request accepted",
      });
    } catch (error) {
      console.error('Error accepting connection request:', error);
      toast({
        title: "Error",
        description: "Failed to accept connection request",
        variant: "destructive",
      });
    }
  };

  const handleRejectRequest = async (connectionId: string) => {
    try {
      const { error } = await supabase
        .from('connections')
        .update({ status: 'rejected' })
        .eq('id', connectionId);

      if (error) throw error;

      setPendingRequests(prev => prev.filter(req => req.id !== connectionId));
      await refreshCounts();

      toast({
        title: "Success",
        description: "Connection request rejected",
      });
    } catch (error) {
      console.error('Error rejecting connection request:', error);
      toast({
        title: "Error",
        description: "Failed to reject connection request",
        variant: "destructive",
      });
    }
  };

  const handleLike = async (itemId: string) => {
    if (!user) return;

    try {
      const item = portfolioProjects.find(i => i.id === itemId);
      if (!item) return;

      if (item.is_liked) {
        // Unlike
        const { error } = await supabase
          .from('portfolio_likes')
          .delete()
          .eq('portfolio_item_id', itemId)
          .eq('user_id', user.id);

        if (error) throw error;

        setPortfolioProjects(prev => prev.map(item => 
          item.id === itemId
            ? { ...item, is_liked: false, likes_count: Math.max(0, item.likes_count - 1) }
            : item
        ));
      } else {
        // Like
        const { error } = await supabase
          .from('portfolio_likes')
          .insert({
            portfolio_item_id: itemId,
            user_id: user.id
          });

        if (error) throw error;

        setPortfolioProjects(prev => prev.map(item => 
          item.id === itemId
            ? { ...item, is_liked: true, likes_count: item.likes_count + 1 }
            : item
        ));
      }
    } catch (error) {
      console.error('Error toggling like:', error);
      toast({
        title: "Error",
        description: "Failed to update like status",
        variant: "destructive",
      });
    }
  };

  const handleRemoveConnection = async (connectionId: string) => {
    try {
      const { error } = await supabase
        .from('connections')
        .delete()
        .eq('id', connectionId);

      if (error) throw error;

      setConnections(prev => prev.filter(conn => conn.id !== connectionId));

      toast({
        title: "Success",
        description: "Connection removed",
      });
    } catch (error) {
      console.error('Error removing connection:', error);
      toast({
        title: "Error",
        description: "Failed to remove connection",
        variant: "destructive",
      });
    }
  };

  if (!user) {
    return (
      <>
        <Navbar />
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-2xl font-bold mb-4">Please sign in to view connections</h1>
        </div>
      </>
    );
  }

  return (
    <>
      <Navbar />
      <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Connections</h1>
      </div>

      <Tabs defaultValue={searchParams.get('tab') || 'connections'} className="w-full" onValueChange={handleTabChange}>
        <TabsList className="mb-4">
          <TabsTrigger value="connections" className="flex items-center gap-2">
            <Users className="h-4 w-4" />
            My Connections
          </TabsTrigger>
          <TabsTrigger value="requests" className="flex items-center gap-2">
            <div className="relative">
              <UserPlus className="h-4 w-4" />
              {pendingConnectionsCount > 0 && (
                <Badge variant="destructive" className="absolute -top-2 -right-2 h-4 w-4 p-0 flex items-center justify-center text-xs">
                  {pendingConnectionsCount}
                </Badge>
              )}
            </div>
            Connection Requests
          </TabsTrigger>
          <TabsTrigger value="messages" className="flex items-center gap-2">
            <div className="relative">
              <MessageSquare className="h-4 w-4" />
              <NotificationBadge type="messages" />
            </div>
            Messages
          </TabsTrigger>
          <TabsTrigger value="portfolio" className="flex items-center gap-2">
            <Folder className="h-4 w-4" />
            Portfolio Feed
          </TabsTrigger>
        </TabsList>

        <TabsContent value="connections">
          <Card className="p-6">
            {connections.length === 0 ? (
              <div className="text-center text-muted-foreground">
                <Users className="h-12 w-12 mx-auto mb-2" />
                <h3 className="text-lg font-medium">No connections yet</h3>
                <p className="mb-4">Start connecting with other students to grow your network!</p>
              </div>
            ) : (
              <div className="space-y-4">
                {connections.map((connection) => (
                  <div key={connection.id} className="flex items-center justify-between p-4 border rounded-lg">
                    <div className="flex items-center gap-4">
                      <Avatar>
                        <AvatarFallback>
                          {connection.other_user_profile?.full_name?.charAt(0)}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <Link 
                          to={`/profile/${connection.requester_id === user?.id ? connection.receiver_id : connection.requester_id}`}
                          className="font-medium hover:text-primary"
                        >
                          {connection.other_user_profile?.full_name}
                        </Link>
                        <p className="text-sm text-muted-foreground">
                          {connection.other_user_profile?.school_name}
                        </p>
                      </div>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => handleRemoveConnection(connection.id)}
                      className="text-destructive hover:text-destructive/90"
                    >
                      Remove
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </Card>
        </TabsContent>

        <TabsContent value="requests">
          <Card className="p-6">
            {pendingRequests.length === 0 ? (
              <div className="text-center text-muted-foreground">
                <UserPlus className="h-12 w-12 mx-auto mb-2" />
                <h3 className="text-lg font-medium">No pending requests</h3>
                <p className="mb-4">You don't have any connection requests at the moment.</p>
              </div>
            ) : (
              <div className="space-y-4">
                {pendingRequests.map((request) => (
                  <div key={request.id} className="flex items-center justify-between p-4 border rounded-lg">
                    <div className="flex items-center gap-4">
                      <Avatar>
                        <AvatarFallback>
                          {request.other_user_profile?.full_name?.charAt(0)}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <Link 
                          to={`/profile/${request.requester_id}`}
                          className="font-medium hover:text-primary"
                        >
                          {request.other_user_profile?.full_name}
                        </Link>
                        <p className="text-sm text-muted-foreground">
                          {request.other_user_profile?.school_name}
                        </p>
                      </div>
                    </div>
                    <div className="flex gap-2">
                      <Button
                        size="sm"
                        onClick={() => handleAcceptRequest(request.id)}
                        className="text-green-600 hover:text-green-700"
                      >
                        <Check className="h-4 w-4" />
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleRejectRequest(request.id)}
                        className="text-destructive hover:text-destructive/90"
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </Card>
        </TabsContent>

        <TabsContent value="messages">
          <Card className="p-0 overflow-hidden">
            <div className="grid grid-cols-[320px_1fr] h-[600px] max-h-[80vh]">
              {/* Conversations List - Instagram Style */}
              <div className="border-r flex flex-col h-full">
                <div className="p-4 border-b">
                  <h3 className="font-semibold text-lg">Messages</h3>
                </div>
                <div className="overflow-y-auto flex-1">
                  {connections.map((connection) => {
                    const otherUserId = connection.requester_id === user?.id 
                      ? connection.receiver_id 
                      : connection.requester_id;
                    
                    // Only show unread indicator for messages where user is the receiver
                    const hasUnreadMessages = messages.some(msg => 
                      msg.sender_id === otherUserId && 
                      msg.receiver_id === user?.id && 
                      !msg.read_status
                    );
                    
                    // Get last message in conversation
                    const conversationMessages = messages.filter(msg => 
                      (msg.sender_id === user?.id && msg.receiver_id === otherUserId) ||
                      (msg.receiver_id === user?.id && msg.sender_id === otherUserId)
                    );
                    
                    const lastMessage = conversationMessages.length > 0 
                      ? conversationMessages[conversationMessages.length - 1] 
                      : null;
                    
                    return (
                      <button
                        key={connection.id}
                        onClick={async () => {
                          // If switching to a different conversation, reset messages and load new ones
                          if (activeConversation !== otherUserId) {
                            setActiveConversation(otherUserId);
                            setMessages([]); // Clear messages while loading
                            setMessageOffset(0);
                            setHasMoreMessages(true);
                            
                            // Load messages for this conversation
                            try {
                              const { data: messagesData, error: messagesError } = await supabase
                                .from('messages')
                                .select('*, read_status')
                                .or(`sender_id.eq.${user.id},receiver_id.eq.${otherUserId},receiver_id.eq.${user.id},sender_id.eq.${otherUserId}`)
                                .order('created_at', { ascending: false })
                                .range(0, 49);
                                
                              if (messagesError) throw messagesError;
                              
                              // Reverse to show oldest first in the UI
                              const chronologicalMessages = [...(messagesData || [])].reverse();
                              
                              // Transform messages with sender and receiver profiles
                              const transformedMessages = await Promise.all(chronologicalMessages.map(async (message) => {
                                const [senderResponse, receiverResponse] = await Promise.all([
                                  supabase
                                    .from('profiles')
                                    .select('full_name, school_name')
                                    .eq('id', message.sender_id)
                                    .single(),
                                  supabase
                                    .from('profiles')
                                    .select('full_name, school_name')
                                    .eq('id', message.receiver_id)
                                    .single()
                                ]);
                                
                                return {
                                  ...message,
                                  sender_profile: senderResponse.data,
                                  receiver_profile: receiverResponse.data
                                };
                              }));
                              
                              setMessages(transformedMessages);
                              
                              // If fewer messages than the limit, there are no more to load
                              if (!messagesData || messagesData.length < 50) {
                                setHasMoreMessages(false);
                              }
                              
                              // Auto-scroll to bottom after loading messages
                              setTimeout(() => {
                                if (messageEndRef.current) {
                                  messageEndRef.current.scrollIntoView({ behavior: 'smooth' });
                                  setIsAtBottom(true);
                                }
                              }, 100);
                            } catch (error) {
                              console.error('Error loading conversation messages:', error);
                              toast({
                                title: "Error",
                                description: "Failed to load messages",
                                variant: "destructive",
                              });
                            }
                          }
                          
                          // Mark messages as read when opening conversation
                          const unreadMessages = messages.filter(msg => 
                            msg.sender_id === otherUserId && 
                            msg.receiver_id === user?.id && 
                            !msg.read_status
                          );
                          
                          if (unreadMessages.length > 0) {
                            try {
                              await markMessagesAsRead(otherUserId);
                              // Update local state immediately
                              setMessages(prev => prev.map(msg => 
                                msg.sender_id === otherUserId && 
                                msg.receiver_id === user?.id && 
                                !msg.read_status
                                  ? { ...msg, read_status: true }
                                  : msg
                              ));
                            } catch (error) {
                              console.error('Error marking messages as read:', error);
                              toast({
                                title: "Error",
                                description: "Failed to update message status",
                                variant: "destructive",
                              });
                            }
                          }
                        }}
                        className={`flex items-center w-full p-4 transition-colors border-b ${
                          activeConversation === otherUserId
                            ? 'bg-blue-50'
                            : 'hover:bg-gray-50'
                        }`}
                      >
                        <Avatar className="h-12 w-12 mr-3">
                          <AvatarFallback className={`${activeConversation === otherUserId ? 'bg-blue-100 text-blue-600' : ''}`}>
                            {connection.other_user_profile?.full_name?.charAt(0)}
                          </AvatarFallback>
                        </Avatar>
                        <div className="flex-1 text-left overflow-hidden">
                          <div className="font-medium flex items-center justify-between">
                            <span className="truncate">{connection.other_user_profile?.full_name}</span>
                            {lastMessage && (
                              <span className="text-xs text-gray-500 ml-2">
                                {new Date(lastMessage.created_at).toLocaleDateString(undefined, {
                                  month: 'short',
                                  day: 'numeric'
                                })}
                              </span>
                            )}
                          </div>
                          {lastMessage && (
                            <p className="text-sm text-gray-500 truncate">
                              {lastMessage.sender_id === user?.id ? 'You: ' : ''}
                              {lastMessage.content}
                            </p>
                          )}
                        </div>
                        {hasUnreadMessages && (
                          <div className="ml-2">
                            <div className="w-3 h-3 rounded-full bg-blue-500" />
                          </div>
                        )}
                      </button>
                    );
                  })}
                </div>
              </div>

              {/* Message Thread - Instagram Style */}
              <div className="flex flex-col bg-white h-full">
                {activeConversation ? (
                  <>
                    {/* Conversation Header */}
                    {(() => {
                      const activeConnection = connections.find(conn => 
                        conn.requester_id === activeConversation || conn.receiver_id === activeConversation
                      );
                      
                      return activeConnection ? (
                        <div className="flex items-center p-4 border-b shrink-0">
                          <Avatar className="h-8 w-8 mr-3">
                            <AvatarFallback>
                              {activeConnection.other_user_profile?.full_name?.charAt(0)}
                            </AvatarFallback>
                          </Avatar>
                          <div>
                            <div className="font-semibold">
                              {activeConnection.other_user_profile?.full_name}
                            </div>
                            <p className="text-xs text-gray-500">
                              {activeConnection.other_user_profile?.school_name}
                            </p>
                          </div>
                        </div>
                      ) : null;
                    })()}

                    {/* Messages */}
                    <ScrollArea 
                      ref={messageContainerRef}
                      className="flex-1 relative bg-gray-50"
                      style={{ height: 'calc(100% - 130px)' }}
                      onScroll={handleMessageScroll}
                    >
                      <div className="p-4">
                        {!isAtBottom && (
                          <Button
                            onClick={scrollToBottom}
                            className="fixed bottom-24 right-8 rounded-full shadow-md z-10"
                            size="sm"
                          >
                            <span className="sr-only">Scroll to bottom</span>
                            <Send className="h-4 w-4 rotate-90" />
                          </Button>
                        )}
                        <div className="space-y-3 flex flex-col min-h-full">
                          {isLoadingMoreMessages && (
                            <div className="text-center py-2">
                              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-500 mx-auto"></div>
                            </div>
                          )}
                          {messages
                            .filter(msg => 
                              (msg.sender_id === user?.id && msg.receiver_id === activeConversation) ||
                              (msg.receiver_id === user?.id && msg.sender_id === activeConversation)
                            )
                            .map((message, index, filteredMessages) => {
                              const isCurrentUser = message.sender_id === user?.id;
                              const previousMessage = index > 0 ? filteredMessages[index - 1] : null;
                              const nextMessage = index < filteredMessages.length - 1 ? filteredMessages[index + 1] : null;
                              
                              // Check if this message is part of a group
                              const isPreviousSameSender = previousMessage && previousMessage.sender_id === message.sender_id;
                              const isNextSameSender = nextMessage && nextMessage.sender_id === message.sender_id;
                              
                              // Determine bubble shape based on position in group
                              let bubbleShape = '';
                              if (!isPreviousSameSender && !isNextSameSender) {
                                bubbleShape = isCurrentUser ? 'rounded-2xl rounded-tr-md' : 'rounded-2xl rounded-tl-md';
                              } else if (!isPreviousSameSender) {
                                bubbleShape = isCurrentUser ? 'rounded-2xl rounded-br-md rounded-tr-md' : 'rounded-2xl rounded-bl-md rounded-tl-md';
                              } else if (!isNextSameSender) {
                                bubbleShape = isCurrentUser ? 'rounded-2xl rounded-tr-md rounded-tl-md' : 'rounded-2xl rounded-tl-md rounded-tr-md';
                              } else {
                                bubbleShape = isCurrentUser ? 'rounded-2xl rounded-tr-md rounded-tl-md' : 'rounded-2xl rounded-tl-md rounded-tr-md';
                              }
                              
                              return (
                                <div
                                  key={message.id}
                                  className={`flex ${isCurrentUser ? 'justify-end' : 'justify-start'} ${!isPreviousSameSender ? 'mt-4' : 'mt-1'}`}
                                >
                                  <div className="flex flex-col max-w-[70%]">
                                    <div
                                      className={`p-3 ${bubbleShape} ${
                                        isCurrentUser
                                          ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white'
                                          : 'bg-gray-200 text-gray-900'
                                      }`}
                                    >
                                      <p className="text-sm">{message.content}</p>
                                    </div>
                                    {!isNextSameSender && (
                                      <div className={`text-xs text-gray-500 mt-1 ${isCurrentUser ? 'text-right mr-1' : 'ml-1'}`}>
                                        {new Date(message.created_at).toLocaleTimeString(undefined, {
                                          hour: '2-digit',
                                          minute: '2-digit'
                                        })}
                                        {isCurrentUser && message.read_status && (
                                          <span className="ml-1 text-blue-500">â€¢ Seen</span>
                                        )}
                                      </div>
                                    )}
                                  </div>
                                </div>
                              );
                            })}
                          <div ref={messageEndRef} />
                        </div>
                      </div>
                    </ScrollArea>

                    {/* Message Input - Instagram Style */}
                    <div className="p-3 border-t flex items-center shrink-0">
                      <form 
                        className="flex w-full items-center"
                        onSubmit={(e) => {
                          e.preventDefault();
                          handleSendMessage();
                        }}
                      >
                        <div className="flex-1 relative">
                          <label 
                            htmlFor="message-input"
                            className="sr-only"
                          >
                            Type a message
                          </label>
                          <input
                            id="message-input"
                            type="text"
                            ref={inputRef}
                            value={newMessage}
                            onChange={(e) => setNewMessage(e.target.value)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                handleSendMessage();
                              }
                            }}
                            placeholder="Message..."
                            className="w-full px-4 py-2 rounded-full border border-gray-300 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                          />
                        </div>
                        <Button
                          type="submit"
                          disabled={!newMessage.trim()}
                          className="ml-2 rounded-full bg-transparent hover:bg-blue-50 text-blue-500 hover:text-blue-600"
                          variant="ghost"
                          size="icon"
                        >
                          <Send className="h-5 w-5" />
                        </Button>
                      </form>
                    </div>
                  </>
                ) : (
                  <div className="flex flex-col items-center justify-center h-full text-gray-500 bg-gray-50">
                    <MessageSquare className="h-12 w-12 mb-4 text-gray-300" />
                    <h3 className="text-xl font-medium mb-2">Your Messages</h3>
                    <p className="text-sm">Select a conversation to start messaging</p>
                  </div>
                )}
              </div>
            </div>
          </Card>
        </TabsContent>

        <TabsContent value="portfolio">
          <Card className="p-0">
            <div 
              className="max-w-xl mx-auto py-4 px-0 overflow-y-auto"
              style={{ height: '600px' }}
              onScroll={handleScroll}
            >
              {portfolioProjects.length === 0 && !isLoadingMore ? (
                <div className="text-center py-8 text-muted-foreground">
                  <Folder className="h-12 w-12 mx-auto mb-2" />
                  <h3 className="text-lg font-medium">No projects yet</h3>
